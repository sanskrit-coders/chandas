"""
Reinforcement Learning Environment for Sanskrit Metrical Poetry Composition

This module provides a Gym-like environment for training models to compose
Sanskrit poetry that adheres to specific metrical patterns (chandas).
"""

import random
import logging
from typing import Dict, Tuple, Any, Optional


from .meter_verifier import MeterVerifier
from .dataset import PoetryDataset


class SanskritPoetryEnv:
    """
    RL environment for Sanskrit metrical poetry composition.

    This environment provides:
    1. A state space representing the current poetry composition task
    2. An action space for generating Sanskrit text
    3. A reward function based on metrical correctness and semantic relevance
    """

    def __init__(self, dataset_path: Optional[str] = None):
        """
        Initialize the environment.

        Args:
            dataset_path: Path to the dataset of poetry tasks
        """
        self.meter_verifier = MeterVerifier()
        self.dataset = PoetryDataset(dataset_path) if dataset_path else None
        self.logger = logging.getLogger(__name__)

        # Current state
        self.current_task = None
        self.current_meter = None
        self.current_topic = None
        self.current_attempt = None
        self.episode_step = 0
        self.max_steps = 5  # Maximum attempts per episode

    def reset(self) -> Dict[str, Any]:
        """
        Reset the environment and return the initial state.

        Returns:
            Initial state dictionary
        """
        # If dataset is available, sample a task
        if self.dataset:
            self.current_task = self.dataset.sample_task()
            self.current_meter = self.current_task['meter']
            self.current_topic = self.current_task['topic']
        else:
            # Default meters and topics if no dataset is provided
            meters = ["अनुष्टुभ्", "वसन्ततिलका", "शार्दूलविक्रीडितम्", 
                     "मन्दाक्रान्ता", "शिखरिणी"]
            topics = ["प्रकृतिः", "प्रेम", "ईश्वरः", "वीरता", "ज्ञानम्"]
            self.current_meter = random.choice(meters)
            self.current_topic = random.choice(topics)
            self.current_task = {
                'meter': self.current_meter,
                'topic': self.current_topic
            }

        self.current_attempt = None
        self.episode_step = 0

        return self._get_state()
    
    def step(self, action: str) -> Tuple[Dict[str, Any], float, bool, Dict[str, Any]]:
        """
        Take a step in the environment.

        Args:
            action: The Sanskrit text generated by the agent

        Returns:
            Tuple of (next_state, reward, done, info)
        """
        self.current_attempt = action
        self.episode_step += 1

        # Verify if the text adheres to the expected meter
        is_correct, details = self.meter_verifier.verify_meter(
            action, self.current_meter)

        # Calculate reward
        reward = self._calculate_reward(is_correct, details)

        # Check if episode is done
        done = is_correct or self.episode_step >= self.max_steps

        # Prepare info dictionary
        info = {
            'meter_verification': {
                'is_correct': is_correct,
                'identified_meters': details.get('identified_meters', {}),
                'is_partial_match': details.get('is_partial_match', False),
                'pattern': details.get('pattern', [])
            },
            'step': self.episode_step,
            'max_steps': self.max_steps
        }
        
        return self._get_state(), reward, done, info
    
    def _get_state(self) -> Dict[str, Any]:
        """
        Get the current state of the environment.
        
        Returns:
            State dictionary
        """
        state = {
            'task': {
                'meter': self.current_meter,
                'topic': self.current_topic
            },
            'attempt': self.current_attempt,
            'step': self.episode_step,
            'max_steps': self.max_steps
        }
        
        # Add meter information to help the agent
        if self.current_meter:
            # First try to get meter info from the meter verifier
            meter_info = self.meter_verifier.get_meter_info(self.current_meter)
            if meter_info:
                state['meter_info'] = meter_info
            # If not found, try to get it from the dataset as a fallback
            elif hasattr(self.dataset, 'tasks') and self.dataset.tasks:
                for task in self.dataset.tasks:
                    if task.get('meter') == self.current_meter and 'meter_info' in task:
                        state['meter_info'] = task['meter_info']
                        break
        
        return state
    
    def _calculate_reward(self, is_correct: bool, details: Dict) -> float:
        """
        Calculate the reward based on metrical correctness and other factors.
        
        Args:
            is_correct: Whether the text adheres to the expected meter
            details: Details from meter verification
            
        Returns:
            Reward value
        """
        # Initialize reward
        reward = 0.0
        
        # Get identified meters
        identified_meters = details.get('identified_meters', {})
        expected_meter = details.get('expected_meter', '')
        
        # Check for exact match (highest reward)
        if is_correct:
            reward = 1.0
            self.logger.info(f"Exact meter match: {expected_meter}")
            return reward
            
        # Check for partial match with expected meter
        if expected_meter in identified_meters.get('partial', set()):
            reward = 0.5
            self.logger.info(f"Partial meter match: {expected_meter}")
            return reward
            
        # Check if any meter was identified exactly
        if identified_meters.get('exact', set()):
            # Some meter was identified exactly, but not the expected one
            reward = 0.2
            self.logger.info(f"Different exact meter identified: {identified_meters['exact']}")
            return reward
            
        # Check if any meter was identified partially
        if identified_meters.get('partial', set()):
            # Some meter was identified partially
            reward = 0.1
            self.logger.info(f"Different partial meter identified: {identified_meters['partial']}")
            return reward
        
        # No meter identified at all
        self.logger.info("No meter identified")
        return reward
    
    def render(self, mode: str = 'human') -> None:
        """
        Render the current state of the environment.
        
        Args:
            mode: Rendering mode
        """
        if mode == 'human':
            print(f"Task: Compose a Sanskrit poem in {self.current_meter} meter about {self.current_topic}")
            if self.current_attempt:
                print(f"Current attempt: {self.current_attempt}")
                
                # Get syllable information
                syllable_info = self.meter_verifier.get_syllable_info(self.current_attempt)
                for line_info in syllable_info:
                    print(f"Line: {line_info['text']}")
                    print(f"Syllables: {' '.join(line_info['syllables'])}")
                    print(f"Weights: {' '.join(line_info['weights'])}")
                    print(f"Pattern: {line_info['pattern']}")
                    print()
                
                # Get meter identification
                identified_meters = self.meter_verifier.identify_meter(self.current_attempt)
                if identified_meters:
                    print("Identified meters:")
                    for match_type, meters in identified_meters.items():
                        print(f"  {match_type}: {', '.join(meters)}")
                else:
                    print("No meters identified.")
            
            print(f"Step: {self.episode_step}/{self.max_steps}")
        else:
            raise NotImplementedError(f"Rendering mode {mode} not implemented.")
